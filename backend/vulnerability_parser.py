import logging
from collections import defaultdict

logger = logging.getLogger(__name__)

SEVERITY_ORDER = {
    'Critical': 0,
    'High': 1,
    'Medium': 2,
    'Low': 3,
    'Info': 4
}

class VulnerabilityAggregator:
    """Aggregate and categorize vulnerabilities from multiple tools"""
    
    def __init__(self):
        self.vulnerabilities = []
    
    def add_from_tool_result(self, tool_result):
        """Extract vulnerabilities from a tool's scan result"""
        tool_name = tool_result.get('tool', 'unknown')
        
        if not tool_result.get('success'):
            logger.warning(f"Skipping {tool_name} - scan failed")
            return
        
        # Extract vulnerabilities based on tool type
        if tool_name == 'nmap':
            self._add_nmap_vulnerabilities(tool_result)
        elif tool_name == 'nikto':
            self._add_nikto_vulnerabilities(tool_result)
        elif tool_name == 'sslyze':
            self._add_sslyze_vulnerabilities(tool_result)
        elif tool_name == 'whatweb':
            self._add_whatweb_risks(tool_result)
    
    def _add_nmap_vulnerabilities(self, result):
        """Add vulnerabilities from Nmap scan"""
        for vuln in result.get('vulnerabilities', []):
            self.vulnerabilities.append({
                'source': 'Nmap',
                'port': vuln.get('port'),
                'service': vuln.get('service', 'unknown'),
                'title': vuln.get('script', 'Vulnerability detected'),
                'description': vuln.get('description', '')[:300],  # Limit length
                'severity': vuln.get('severity', 'Info'),
                'category': 'Network Vulnerability'
            })
    
    def _add_nikto_vulnerabilities(self, result):
        """Add vulnerabilities from Nikto scan"""
        for vuln in result.get('vulnerabilities', []):
            self.vulnerabilities.append({
                'source': 'Nikto',
                'port': 80,  # Default HTTP port
                'service': 'http',
                'title': 'Web Server Vulnerability',
                'description': vuln.get('description', '')[:300],
                'severity': vuln.get('severity', 'Medium'),
                'category': 'Web Application'
            })
    
    def _add_sslyze_vulnerabilities(self, result):
        """Add SSL/TLS issues from SSLyze"""
        for vuln in result.get('vulnerabilities', []):
            self.vulnerabilities.append({
                'source': 'SSLyze',
                'port': 443,
                'service': 'https',
                'title': 'SSL/TLS Configuration Issue',
                'description': vuln.get('description', '')[:300],
                'severity': vuln.get('severity', 'Medium'),
                'category': 'SSL/TLS'
            })
    
    def _add_whatweb_risks(self, result):
        """Add technology risks from WhatWeb"""
        technologies = result.get('technologies', [])
        
        # Check for outdated or risky technologies
        risky_tech = ['PHP/5', 'Apache/2.2', 'jQuery/1', 'WordPress']
        
        for tech in technologies:
            for risk in risky_tech:
                if risk in tech:
                    self.vulnerabilities.append({
                        'source': 'WhatWeb',
                        'port': 80,
                        'service': 'http',
                        'title': f'Outdated Technology: {tech}',
                        'description': f'Detected potentially outdated or vulnerable technology: {tech}',
                        'severity': 'Low',
                        'category': 'Technology Stack'
                    })
    
    def get_aggregated_vulnerabilities(self):
        """Get all vulnerabilities grouped by severity"""
        grouped = defaultdict(list)
        
        for vuln in self.vulnerabilities:
            severity = vuln.get('severity', 'Info')
            grouped[severity].append(vuln)
        
        # Sort by severity
        sorted_vulns = {}
        for severity in ['Critical', 'High', 'Medium', 'Low', 'Info']:
            if severity in grouped:
                sorted_vulns[severity] = grouped[severity]
        
        return sorted_vulns
    
    def get_summary_stats(self):
        """Get vulnerability statistics"""
        stats = {
            'total': len(self.vulnerabilities),
            'by_severity': defaultdict(int),
            'by_category': defaultdict(int),
            'by_source': defaultdict(int)
        }
        
        for vuln in self.vulnerabilities:
            stats['by_severity'][vuln.get('severity', 'Info')] += 1
            stats['by_category'][vuln.get('category', 'Other')] += 1
            stats['by_source'][vuln.get('source', 'Unknown')] += 1
        
        return dict(stats)
    
    def get_critical_findings(self):
        """Get only critical and high severity findings"""
        critical_high = []
        for vuln in self.vulnerabilities:
            if vuln.get('severity') in ['Critical', 'High']:
                critical_high.append(vuln)
        return critical_high
    
    def generate_recommendations(self):
        """Generate security recommendations based on findings"""
        recommendations = []
        stats = self.get_summary_stats()
        
        if stats['by_severity'].get('Critical', 0) > 0:
            recommendations.append("ğŸ”´ CRITICAL: Immediately patch critical vulnerabilities to prevent exploitation.")
        
        if stats['by_severity'].get('High', 0) > 0:
            recommendations.append("ğŸŸ  HIGH PRIORITY: Address high-severity issues as soon as possible.")
        
        # Check for specific categories
        if stats['by_category'].get('SSL/TLS', 0) > 0:
            recommendations.append("ğŸ”’ Update SSL/TLS configuration to use modern, secure protocols and ciphers.")
        
        if stats['by_category'].get('Web Application', 0) > 0:
            recommendations.append("ğŸŒ Review web application security and apply latest patches.")
        
        if stats['by_category'].get('Technology Stack', 0) > 0:
            recommendations.append("âš™ï¸ Update outdated software components to their latest stable versions.")
        
        if not recommendations:
            recommendations.append("âœ… No critical issues detected. Continue monitoring and regular security assessments.")
        
        return recommendations
